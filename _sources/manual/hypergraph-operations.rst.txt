===========================
Basic hypergraph operations
===========================

At the heart of Graphbrain lies the Semantic Hypergraph (SH). In practical terms, we will talk simply about *hypergraphs*, and we will treat them as a type of database, which contains a searchable collection of hyperedges.

Graphbrain provides abstractions to create, modify and search persistent hypergraph databases, as well as to define and manipulate hyperedges. In this section we introduce these basic operations, upon which all aspects of the library rely on.



The two central functions of Graphbrain: hgraph() and hedge()
=============================================================

The root namespace ``graphbrain`` contains the two most fundamental functions of the library:

- ``hgraph(locator_string)``, which creates/opens a persistent hypergraph.
- ``hedge(source)``, which creates a hyperedge from a string or a Python list or tuple.

In fact, the latter is implemented in ``graphbrain.hyperedge``, but it is imported to the root namespace by default for convenience. We will see that, with just these two functions, a lot can be achieved.


Creating and manipulating hyperedges
====================================

Graphbrain defines the object class ``Hyperedge``, which provides a variety of methods to work with hyperedges. The full interface of this class is described in the API reference. However, these objects are not meant to be instantiated directly. Instead, the ``hedge`` function can be used to create such an object directly from a string representation conforming to the SH notation. For example::

   from graphbrain import hedge
   edge = hedge('(plays/P.so mary/C chess/C)')

In the above example, ``edge`` is an instance of the ``Hyperedge`` class. Hyerpedges are Python sequences. In fact, the class ``Hyperedge`` is derived from ``tuple``, so it makes it possible to do things such as::

   person = edge[1]


In this case, ``person`` will be assigned the second element of the initial hyperedge, which happens to be the atom ``mary/C``. Range selector also work, but they do not automatically produce hyperedges, because subranges of the element of a semantic hyperedge are not guaranteed to be valid semantic hyperedges themselves. Instead, simple tulpes are returned. For example, ``edge[1:]`` from the example is not a valid hyperedge. Nevertheless, such tuples of hyperedges are often useful::


   >>> edge[1:]
   (mary/C, chess/C)
   >>> type(edge[1:])
   <class 'tuple'>

It is possible to test a hyperedge for atomicity like this::

   >>> edge.is_atom()
   False
   >>> person.is_atom()
   True

Another frequently useful task if that of determining the type of a hyperedge::

   >>> edge.type()
   'R'
   >>> edge[0].type()
   'P'
   >>> person.type()
   'C'


Creating and populating hypergraphs
===================================

TODO


Checking if a hyperedge exists
==============================

TODO


The neighborhood of a hyperedge
===============================

TODO


Searching for hyperedges
========================

TODO


Checking type and atomicity of hyperedges
=========================================

TODO


Working with hyperedge sequences
================================

TODO